---
title: "A8a-ts_analysis_val"
author: "Jasper"
format: html
editor: visual
---

Script that performs the entire time series analysis (A2, A3, A4, A5, A6, A7) for the validation points. 

```{r}
library(tidyverse)
library(sf)
library(fable)
library(fabletools)
library(feasts)
library(data.table)
library(terra)
library(lubridate)
library(tsibble)
library(ggplot2)
library(scales)
library(zoo)
library(caret)
library(lme4)
library(ranger)
library(ROCit)
library(plotly)
library(viridis)
library(TSS.RESTREND)
library(scales)
```

# Import and pre-process validation data

```{r}
# Add column validation data
val_pnts <- st_read('data/validation_points.GeoJSON')
#val_pnts <- val_pnts %>% 
#  arrange(country, regreened) %>% 
#  mutate(plotID = seq(1,nrow(val)))

# Write validation point data as geojson and csv
st_write(obj=val_pnts, dsn='data/validation_points.GeoJSON', driver='GeoJSON')
st_write(obj=val_pnts, dsn='data/validation_points.csv', driver='CSV')
#st_write(obj=val_pnts[val_pnts$regreened==0,], dsn='data/validation_points_0.GeoJSON', driver='GeoJSON')
```

# Extract satellite information
Extract the landsat 8 and GPM satellite information using the GEE extract script (A2)


# Create reflectance dataframe for validation points
Function for cloud filtering

```{r}
cloud_landsat <- function(x){
  bits <- as.numeric(intToBits(x))[1:16]
  if(bits[7] == 1 && bits[5] == 0 && bits[3] == 0){
    return(0)
  }
  else(return(1))
}
```

Convert to reflectance and add dates

```{r}
refl_val <- fread('output/gee/Val_refl_l8.csv', select =c('date', 'SR_B4', 'SR_B5','QA_PIXEL','plotID'))  

refl_val$date <- as.Date(refl_val$date, tryFormats = "%d/%m/%Y")
  
# Scale DN values to reflectance values
scale_fac <- 0.0000275
offset <- -0.2
refl_val[,c('SR_B4', 'SR_B5')] <- (refl_val[,c('SR_B4', 'SR_B5')] * scale_fac) + offset

# Remove negative reflectance
refl_val <- refl_val[refl_val$SR_B4 >= 0,]
refl_val <- refl_val[refl_val$SR_B5 >= 0,]
  
# Remove clouds
refl_val$clouds <- 0
refl_val$clouds <- lapply(refl_val$QA_PIXEL, cloud_landsat) # Apply function to all pixels 
refl_val <- refl_val[refl_val$clouds==0,] # Filter out pixels with clouds

# Compute some VIs
refl_val$ndvi <- (refl_val$SR_B5 - refl_val$SR_B4) / (refl_val$SR_B5 + refl_val$SR_B4)
  
# Take average per validation point and date
#(This is to remove duplicates with the same date and plotID as a result of overlapping images and a single point falling in two images on the same date)
refl_aggr_val <- refl_val[,.(ndvi=mean(ndvi,na.rm=T)), by=list(plotID, date)]

# Add yearmon
refl_aggr_val$yearmon <- as.Date(ISOdate(year(refl_aggr_val$date), month(refl_aggr_val$date), 15))
```


# Extract the GPM at validation points
Import

```{r}
# gpm
gpm <- rast('output/gee/gpm/Val_GPM_stack.tif')

# convert validation points to terra:vector
val_pnts <- vect(val_pnts)
```

Set time series parameters

```{r}
# Set start/end
start_ts <- as.Date('2012-9-01')
end_ts <- as.Date('2023-04-15')

# Determine number of months in time series period
months_dif <- (year(end_ts) - year(start_ts)) * 12 + (month(end_ts) - month(start_ts))
months_ts <- seq(ymd(start_ts), by = "month", length.out=months_dif)
```

Extract GPM at validation points and assign date + plotID

```{r}
# Assign dates to gpm_stack layers
names(gpm) <- months_ts
  
#### Extract values for each layer
gpm_val <- data.table(extract(gpm, val_pnts, cells=F))
gpm_val <- gpm_val[,-c('ID')] # remove ID column
rownames(gpm_val) <- val_pnts$plotID

# Transpose df
gpm_ts <- cbind(row = as.integer(rownames(gpm_val)), stack(gpm_val))
  
# Clean df
names(gpm_ts) <- c('plotID', 'prcp_month', 'date')
gpm_ts$yearmon <- as.Date(ISOdate(year(gpm_ts$date), month(gpm_ts$date), 15))

# Concert val_pnts back to sf object
val_pnts <- st_as_sf(val_pnts)
```


# Add precipitation to reflectance ts
```{r}
# Convert val_pnts to datatable 
val_pnts_dt <- data.table(val_pnts)

# Merge reflectance ts with precipitation data
val_ts <- merge(refl_aggr_val, gpm_ts[,c('plotID', 'yearmon','prcp_month')],
               by=c('plotID', 'yearmon'), all.y=T)

# Write complete validation time series
fwrite(val_ts, 'output/time_series/Val_l8_ts.csv')
val_ts <- fread('output/time_series/Val_l8_ts.csv')
```


# Vegetation modeling
Cut off dates outside period of interest
```{r}
# Filter out time stamps before the observation
#val_ts <- val_ts[val_ts$yearmon > as.Date('2013-01-01') & val_ts$yearmon < as.Date('2022-11-01')]
```


Create tsibble for analysis

```{r}
# Creates tsibble with lagged precipitation and interpolate the missing ndvi values
val_ts_pnt <- val_ts %>% 
  group_by(plotID, yearmon) %>% 
  summarize(ndvi=mean(ndvi, na.rm=T),
            prcp=mean(prcp_month)) %>% 
  # Add lagged precipitation variables
  mutate(prcp_lag1=data.table::shift(prcp, n=1, type='lag'),
         prcp_lag2=data.table::shift(prcp, n=2, type='lag')) %>% 
  # Check if plot ts is all NAs and exclude
  mutate(entire_na = length(which(!is.na(ndvi))) == 0) %>% 
  filter(!entire_na) %>% 
  # Exclude NAs when at beginning or end of time series
  slice(min(which(!is.na(ndvi))):max(which(!is.na(ndvi)))) %>% 
  # Remove the entire.na column
  select(!entire_na) %>% 
  # Interpolate NDVI values
  mutate(yearmonth=yearmonth(as.character(yearmon)),
         ndvi_int=na.approx(ndvi)) %>% 
  # Convert to tsibble
  as_tsibble(key=plotID, index=yearmonth) %>% 
  # Filter out time stamps before the observation
  filter(yearmon > as.Date('2013-01-01') & yearmon < as.Date('2023-01-01'))

fwrite(val_ts_pnt, 'output/time_series/Val_ts_pnt.csv')
val_ts_pnt <- read_csv('output/time_series/Val_ts_pnt.csv')

# Convert to tsibble after import
val_ts_pnt <- val_ts_pnt %>%  
  mutate(yearmonth=yearmonth(as.character(yearmon))) %>% 
  # Convert to tsibble
  as_tsibble(key=plotID, index=yearmonth)

# Create reference and validation sets
val_ref_pnt <- val_ts_pnt %>% filter(year(yearmonth) < 2017)
val_prd_pnt <- val_ts_pnt %>% filter(year(yearmonth) >= 2017)
```


Train ARIMA models and predict

```{r}
# Train ARIMA models
val_armax_pnt <- val_ref_pnt %>% 
  model(ARIMA(ndvi_int ~ prcp + prcp_lag1 + prcp_lag2 + pdq(d=0) + PDQ(D=0), stepwise = T, ic='aicc'))

# Forecast ndvi based on models and precipitation
val_fc_pnt <- fabletools::forecast(val_armax_pnt, new_data = val_prd_pnt[,c('yearmonth', 'prcp', 'prcp_lag1', 'prcp_lag2', 'plotID')])

# Extract 95% confidence levels
val_pnt_ci <- val_fc_pnt$ndvi_int %>% 
  hilo(80) 
val_fc_pnt <- val_fc_pnt %>% 
  mutate(upper = val_pnt_ci$upper,
         lower = val_pnt_ci$lower)

# Save the ARIMA models and forecast
save(val_fc_pnt, file = 'output/models/Val_l8_fc_pnt.RDS')
save(val_armax_pnt, file = 'output/models/Val_l8_armax_pnt.RDS')
load(file = 'output/models/Val_l8_fc_pnt.RDS')
load(file = 'output/models/Val_l8_armax_pnt.RDS')
```



# Interpret vegetation modeling
Prepare data
```{r}
# Select relevant rows and add yearmon column
val_fc_pnt_dt <- data.table(val_fc_pnt[,c('.mean', 'yearmonth', 'plotID', 'upper', 'lower')])
names(val_fc_pnt_dt)[names(val_fc_pnt_dt) == '.mean'] <- 'pred_test'
val_fc_pnt_dt$yearmon <- as.Date(ISOdate(year(val_fc_pnt_dt$yearmonth), month(val_fc_pnt_dt$yearmonth), 15))

# Merge actual ndvi with the predicted ndvi
val_fc_ts <- merge(val_ts_pnt, val_fc_pnt_dt[,-c('yearmonth')], by=c('yearmon', 'plotID'), all.x=T)
val_fc_ts$yearmonth <- yearmonth(val_fc_ts$yearmon)

# Merge actual ndvi with predicted reference ndvi
val_fc_ts <- merge(val_fc_ts, residuals(val_armax_pnt)[c('plotID', 'yearmonth', '.resid')], 
                   by=c('yearmonth', 'plotID'), all.x=T)

# Compute training prediction
val_fc_ts$pred_train <- val_fc_ts$ndvi_int + val_fc_ts$.resid

# Combine test and training prediction into one and convert to tsibble
val_fc_ts <- val_fc_ts %>% 
  tsibble(key=plotID, index=yearmonth) %>% 
  mutate(ndvi_pred = if_else(is.na(pred_test), pred_train, pred_test))

# Add the aridity index values to the validation plots
ai <- rast('../../data/rasters/Aridity_index_regreening.tif')
val_pnts <- terra::extract(ai, val_pnts, ID = FALSE, bind = TRUE) %>% st_as_sf() %>% rename(aridity_index = b1)  %>% mutate(aridity_index = aridity_index*0.0001)

# Add validation data to time series
val_fc_ts <- val_fc_ts %>% 
  right_join(val_pnts[,c('plotID', 'regreened', 'aridity_index')], by='plotID') %>% 
  # For caret randomforest, regreened variable cannot start with a number
  mutate(regreened = if_else(regreened == 1, 'yes', 'no'))
```

Create dataset with MAE (and other stats) and plot

```{r}
val_mae <- val_fc_ts %>% 
  mutate(test_res = ndvi_int - upper,
         test_res_0 = if_else(ndvi_int > upper, ndvi_int - upper, 0),
         pred_resid = pred_test - ndvi_int,
         training = if_else(!is.na(pred_train), 1, 0)) %>% 
  tibble() %>% 
  group_by(plotID) %>% 
  summarise(regreened = first(regreened),
            plotID = first(plotID),
            aridity_index = first(aridity_index),
            ndvi=mean(ndvi_int),
            sd=sd(ndvi_int),
            n = n(),
            n_training = sum(training),
            mae = sum(test_res, na.rm=T) / (n - n_training),
            mae_0 = sum(test_res_0, na.rm=T) / (n - n_training) * 100,
            maep = sum((test_res/ndvi_int)*100, na.rm=T) / (n - n_training),
            rmse_test = sum(sqrt(pred_resid^2), na.rm=T) / (n - n_training),
            rmse_train = sum(sqrt(.resid^2), na.rm=T) / n_training) %>% 
  mutate(Ecosystem = if_else(aridity_index < 0.2, 'Arid', NA),
        Ecosystem = if_else(aridity_index >= 0.2 & aridity_index < 0.5, 'Semi-Arid', Ecosystem),
        Ecosystem = if_else(aridity_index > 0.5, 'Dry sub-humid', Ecosystem)) %>%
  right_join(val_pnts[,c('plotID', 'country')], by='plotID') %>% 
  group_by(Ecosystem)

#st_write(st_as_sf(val_mae, sf_column_name = "geometry"), 'output/plot_data/all_countries/val_mae.GeoJSON')
write_csv(val_mae, 'output/plot_data/all_countries/val_mae.csv')
val_mae <- read_csv('output/plot_data/all_countries/val_mae.csv')
```


Test accuracy of proposed method

```{r}
# Test accuracies of various MAE thresholds
interval <- seq(1, 2, by = 0.01)

for (i in interval){
  binary <- val_mae %>% 
    mutate(bin_class = if_else(mae_0 <= i, 'no', 'yes'))
  
  cm <- confusionMatrix(factor(binary$bin_class), 
                factor(binary$regreened), positive='yes', mode='everything')
  print(paste('The mean absolute error threshold is',i))
  print(cm)
}

# Best classification MAEp threshold = 1.4
#val_mae[val_mae$Ecosystem == 'Arid',]
binary <- val_mae %>% 
  #filter(Ecosystem=='Arid') %>% 
  mutate(bin_class = if_else(mae_0 <= 1.3, 'no', 'yes'))

  
cm <- confusionMatrix(factor(binary$bin_class), 
                      factor(binary$regreened), 
                      positive='yes', mode='everything')

write.csv(as.matrix(cm,what='classes'), 'figures/acc_validation.csv')
write.csv(as.matrix(cm), 'figures/cm_validation.csv')
```


Perform RESTREND analysis
```{r}
# RESTREND
val_mae <- read_csv('output/plot_data/all_countries/val_mae.csv')
val_ts_pnt <- read_csv('output/time_series/Val_ts_pnt.csv')
val_ts_pnt <- val_ts_pnt %>%  
  mutate(yearmonth=yearmonth(as.character(yearmon))) %>% 
  as_tsibble(key=plotID, index=yearmonth)

val_max_pnt <- val_ts_pnt %>% 
  tibble() %>% 
  mutate(Year = year(yearmonth)) %>% 
  group_by(Year, plotID) %>% 
  summarise(ndvi_max = max(ndvi, na.rm=TRUE),
            prcp_sum = sum(prcp, na.rm=TRUE)) %>% 
  filter(Year > 2015 & Year < 2023) %>% 
  right_join(val_mae[,c('plotID', 'country','regreened','Ecosystem')], by='plotID')


restrend_df <- data.frame()
for (i in unique(val_max_pnt$plotID)){
  print(i)

  plot_df <- val_max_pnt[val_max_pnt$plotID==i,] 

  plot_ts <- ts(plot_df[,c("ndvi_max", "prcp_sum")], start = min(plot_df$Year), end = max(plot_df$Year), frequency = 1)

  restrend_output <- RESTREND(plot_ts[,'ndvi_max'], plot_ts[,'prcp_sum'], seq(start(plot_ts)[1], end(plot_ts)[1]), sig = 1, retnonsig=TRUE)

  restrend_row_coef <- data.frame(restrend_output$ols.summary$OLS.table)[2:3,]
  restrend_row_coef$fit <- row.names(restrend_row_coef)
  restrend_row_coef$plotID <- i
  restrend_row_coef$country <- val_max_pnt$country[val_max_pnt$plotID==i][1]
  restrend_row_coef$regreened <- val_max_pnt$regreened[val_max_pnt$plotID==i][1]
  restrend_row_coef$Ecosystem <- val_max_pnt$Ecosystem[val_max_pnt$plotID==i][1]

  restrend_df <- rbind(restrend_df, restrend_row_coef)
}
restrend_df <- restrend_df[restrend_df$fit =='RESTREND.fit',]
```




BACI
```{r}
val_mae <- read_csv('output/plot_data/all_countries/val_mae.csv') %>% 
  mutate(Ecosystem = factor(Ecosystem, levels = c("Arid","Semi-Arid","Dry sub-humid")))

val_ts_pnt <- read_csv('output/time_series/Val_ts_pnt.csv')
val_ts_pnt <- val_ts_pnt %>%  
  mutate(yearmonth=yearmonth(as.character(yearmon))) %>% 
  as_tsibble(key=plotID, index=yearmonth) %>% 
  left_join(val_mae[,c('plotID','country','regreened','Ecosystem')], by='plotID')

control_ndvi <- val_ts_pnt[val_ts_pnt$regreened == 'no',]  %>% 
  tibble() %>% 
  mutate(ba_period = if_else(yearmon < as.Date('2017-01-01'), 'before', 'after')) %>% 
  group_by(country, ba_period) %>% 
  summarise(ndvi_control = mean(ndvi, na.rm=TRUE))

impact_ndvi <- val_ts_pnt  %>% 
  tibble() %>% 
  mutate(ba_period = if_else(yearmon < as.Date('2017-01-01'), 'before', 'after')) %>% 
  group_by(country, plotID, ba_period) %>% 
  summarise(ndvi_impact = mean(ndvi, na.rm=TRUE),
            Ecosystem = first(Ecosystem),
            regreened = first(regreened))

ggplot(yearly_ndvi[yearly_ndvi$country=='Niger',])+
  geom_line(aes(x=year, y = ndvi, col = regreened, group = plotID))

baci <- impact_ndvi %>% 
  left_join(control_ndvi, by=c('country', 'ba_period'))

baci$contrast <- NA
baci$pvalue <- NA
baci$slope <- NA
for (i in unique(baci$plotID)){
  print(i)
  baci_plot <- baci[baci$plotID == i,]
  contrast <- (baci_plot[baci_plot$ba_period == 'after',]$ndvi_control - baci_plot[baci_plot$ba_period == 'before',]$ndvi_control) - (baci_plot[baci_plot$ba_period == 'after',]$ndvi_impact - baci_plot[baci_plot$ba_period == 'before',]$ndvi_impact)

  baci[baci$plotID == i,]$contrast <- contrast

  # Compute significance
  yearly_ndvi_impact <- val_ts_pnt  %>% 
    tibble() %>% 
    filter(plotID == i) %>% 
    mutate(ba_period = if_else(yearmon < as.Date('2017-01-01'), 'before', 'after')) %>% 
    group_by(country, plotID, ba_period, year(yearmon)) %>% 
    rename(year = `year(yearmon)`) %>% 
    summarise(ndvi = mean(ndvi, na.rm=TRUE),
              Ecosystem = first(Ecosystem),
              regreened = first(regreened)) %>% 
    mutate(regreened = 'yes') %>% 
    ungroup()

  yearly_ndvi_control_country <- yearly_ndvi_control[yearly_ndvi_control$country == yearly_ndvi_impact$country[1],]

  lm_ba <- lm(ndvi ~ ba_period*regreened + (1|plotID) + (1|year), data = rbind(yearly_ndvi_impact, yearly_ndvi_control))

  baci[baci$plotID == i,]$pvalue <- summary(lm_ba)$coefficients[4,4]
  baci[baci$plotID == i,]$slope <- summary(lm_ba)$coefficients[4,1]
}
ggplot(baci)+
  geom_boxplot(aes(x = country, y = pvalue, col = regreened))






# BACI using sythetic model
control_ndvi <- val_fc_ts  %>% 
  tibble() %>% 
  mutate(ba_period = if_else(yearmon < as.Date('2017-01-01'), 'before', 'after')) %>% 
  group_by(plotID, ba_period) %>% 
  summarise(ndvi_control = mean(ndvi_pred, na.rm=TRUE))

impact_ndvi <- val_fc_ts  %>% 
  tibble() %>% 
  mutate(ba_period = if_else(yearmon < as.Date('2017-01-01'), 'before', 'after')) %>% 
  group_by(country, plotID, ba_period) %>% 
  summarise(ndvi_impact = mean(ndvi, na.rm=TRUE),
            Ecosystem = first(Ecosystem),
            regreened = first(regreened))

syn_baci <- impact_ndvi %>% 
  left_join(control_ndvi, by=c('plotID', 'ba_period'))

yearly_ndvi_control <- val_ts_pnt[val_ts_pnt$regreened == 'no',]  %>% 
  tibble() %>% 
  mutate(ba_period = if_else(yearmon < as.Date('2017-01-01'), 'before', 'after'),
        plotID = 0) %>% 
  group_by(country, plotID, ba_period, year(yearmon)) %>% 
  rename(year = `year(yearmon)`) %>% 
  summarise(ndvi = mean(ndvi, na.rm=TRUE),
            Ecosystem = first(Ecosystem),
            regreened = first(regreened))

syn_baci$contrast <- NA
for (i in unique(syn_baci$plotID)){
  print(i)
  baci_plot <- syn_baci[baci$plotID == i,]
  contrast <- (baci_plot[baci_plot$ba_period == 'after',]$ndvi_control - baci_plot[baci_plot$ba_period == 'before',]$ndvi_control) - (baci_plot[baci_plot$ba_period == 'after',]$ndvi_impact - baci_plot[baci_plot$ba_period == 'before',]$ndvi_impact)

  syn_baci[syn_baci$plotID == i,]$contrast <- contrast
}
```



Determine significance difference
```{r}
i <- 113
# Compare control sites with actual
yearly_ndvi <- val_ts_pnt  %>% 
  tibble() %>% 
  mutate(ba_period = if_else(yearmon < as.Date('2017-01-01'), 'before', 'after')) %>% 
  group_by(country, plotID, ba_period, year(yearmon)) %>% 
  rename(year = `year(yearmon)`) %>% 
  summarise(ndvi = mean(ndvi, na.rm=TRUE),
            Ecosystem = first(Ecosystem),
            regreened = first(regreened)) %>% 
  ungroup()
yearly_ndvi_control <- yearly_ndvi[yearly_ndvi$regreened == 'no',]

yearly_ndvi_control <- val_ts_pnt[val_ts_pnt$regreened == 'no',]  %>% 
  tibble() %>% 
  mutate(ba_period = if_else(yearmon < as.Date('2017-01-01'), 'before', 'after'),
        plotID = 0) %>% 
  group_by(country, plotID, ba_period, year(yearmon)) %>% 
  rename(year = `year(yearmon)`) %>% 
  summarise(ndvi = mean(ndvi, na.rm=TRUE),
            Ecosystem = first(Ecosystem),
            regreened = first(regreened))



yearly_ndvi_impact <- val_ts_pnt  %>% 
  tibble() %>% 
  filter(plotID == i) %>% 
  mutate(ba_period = if_else(yearmon < as.Date('2017-01-01'), 'before', 'after')) %>% 
  group_by(country, plotID, ba_period, year(yearmon)) %>% 
  rename(year = `year(yearmon)`) %>% 
  summarise(ndvi = mean(ndvi, na.rm=TRUE),
            Ecosystem = first(Ecosystem),
            regreened = first(regreened)) %>% 
  mutate(regreened = 'yes') %>% 
  ungroup()

yearly_ndvi_control <- yearly_ndvi_control[yearly_ndvi_control$country == yearly_ndvi_impact$country[1],]
yearly_ndvi_control <- yearly_ndvi_control[yearly_ndvi_control$country == yearly_ndvi_impact$country[1],]


ggplot(rbind(yearly_ndvi_impact, yearly_ndvi_control))+
  geom_line(aes(x=year, y = ndvi, col = regreened))

lm_ba <- glmer(rescale(ndvi, to = c(0,1)) ~ ba_period*regreened + (1|year), 
                       data = rbind(yearly_ndvi_impact, yearly_ndvi_control), family = binomial)


lm_ba <- lm(ndvi ~ ba_period*regreened + (1|plotID) + (1|year), data = rbind(yearly_ndvi_impact, yearly_ndvi_control))
summary(lm_ba)   
lm_ba


# Compare prediction with actual
x <- val_fc_ts  %>% 
  filter(plotID ==115) %>% 
  tibble() %>% 
  mutate(ba_period = if_else(yearmon < as.Date('2017-01-01'), 'before', 'after')) %>% 
  group_by(year(yearmon), ba_period) %>% 
  rename(year = `year(yearmon)`) %>% 
  summarise(impact = mean(ndvi, na.rm=TRUE),
            control = mean(ndvi_pred, na.rm=TRUE)) %>% 
  pivot_longer(cols = c(impact, control), names_to = 'impact_control', values_to = 'ndvi') %>% 
  ungroup()

ggplot(x)+
  geom_line(aes(x=year, y = ndvi, col = impact_control, group = impact_control))+
  geom_point(aes(x=year, y = ndvi, col = impact_control, group = impact_control))


lm_ba <- lm(ndvi ~ ba_period*impact_control, data = x, family = binomial)
summary(lm_ba)   
lm_ba



yearly_ndvi <- val_ts_pnt  %>% 
  tibble() %>% 
  mutate(ba_period = if_else(yearmon < as.Date('2017-01-01'), 'before', 'after')) %>% 
  group_by(country, ba_period, year(yearmon)) %>% 
  rename(year = `year(yearmon)`) %>% 
  summarise(ndvi = mean(ndvi, na.rm=TRUE),
            Ecosystem = first(Ecosystem),
            regreened = first(regreened))


lm_ba <- glmer(rescale(ndvi, to = c(0,1)) ~ ba_period*regreened + (1|plotID) + (1|year) + (1|plotID:year), data = yearly_ndvi, family = binomial)
summary(lm_ba)   
lm_ba


```


Find optimal accuracy MAEp, RESTREND and BACI
```{r}
##### Test accuracies of various MAE thresholds
interval <- seq(0.5, 2, by = 0.1)
# MAE threshold
# Arid: F1: 0.86 at 0.8 threshold
# Semi-arid: F1: 0.89 at 1.4 threshold
# Sub-humid: F1: 0.77 at 0.7 trheshold
# Overall: F1: 0.84 at 1 threshold
for (i in 1){
  binary <- val_mae[val_mae$Ecosystem == 'Dry sub-humid',] %>% 
    mutate(bin_class = if_else(mae_0 <= i, 'no', 'yes'))
  
  cm <- confusionMatrix(factor(binary$bin_class), 
                factor(binary$regreened), positive='yes', mode='everything')
  print(paste('The mean absolute error threshold is',i))
  print(cm)
}

###### Test accuracies of various RESTREND slope thresholds
interval <- seq(0.001, 0.02, by = 0.001)
# Arid: F1: 0.92 at 0.01 threshold
# Semi-arid: F1: 0.88 at 0.013 threshold
# Sub-humid: F1: 0.72 at 0.009 trheshold
# Overall: F1: 0.79 at 0.004 threshold
for (i in 0.004){
  binary <- restrend_df %>% 
    mutate(bin_class = if_else(slope <= i, 'no', 'yes'))
  
  cm <- confusionMatrix(factor(binary$bin_class), 
                factor(binary$regreened), positive='yes', mode='everything')
  print(paste('The mean absolute error threshold is',i))
  print(cm)
}

###### Test accuracies of various BACI relative contrast thresholds
interval <- seq(-0.04, -0.01, by = 0.005)
# Arid: F1: 0.92 at 0.01 threshold
# Semi-arid: F1: 0.88 at 0.013 threshold
# Sub-humid: F1: 0.72 at 0.009 trheshold
# Overall: F1: 0.85 at -0.025 threshold
for (i in -0.025){
  binary <- baci[baci$Ecosystem == 'Dry sub-humid',] %>% 
    mutate(bin_class = if_else(contrast >= i, 'no', 'yes'))
  
  cm <- confusionMatrix(factor(binary$bin_class), 
                factor(binary$regreened), positive='yes', mode='everything')
  print(paste('The mean absolute error threshold is',i))
  print(cm)
}


###### Test accuracies of synthetic BACI approach
interval <- seq(-0.015, -0.025, by = 0.001)
# Arid: F1: 0.92 at 0.01 threshold
# Semi-arid: F1: 0.88 at 0.013 threshold
# Sub-humid: F1: 0.72 at 0.009 trheshold
# Overall: F1: 0.85 at -0.025 threshold
for (i in interval){
  binary <- syn_baci %>% 
    mutate(bin_class = if_else(contrast >= i, 'no', 'yes'))
  
  cm <- confusionMatrix(factor(binary$bin_class), 
                factor(binary$regreened), positive='yes', mode='everything')
  print(paste('The mean absolute error threshold is',i))
  print(cm)
}
```








Perform TSS RESTREND 
```{r}
val_ts <- fread('output/time_series/Val_l8_ts.csv')

ACT.table = NULL
CTSR.TM = NULL
acu.TM = NULL
VI.index = FALSE
rf.b4 = FALSE
rf.af = FALSE
sig = 0.05
season = "none"
exclude = 0
allow.negative = FALSE
allowneg.retest = FALSE
h = 0.15
retnonsig=TRUE
BFraw = FALSE

tss_restrend_df <- data.frame()
for (i in unique(val_max_pnt$plotID)[1:nrow(val_mae)]){
    print(i)

    ########## Prepare data
    output_list <- prepare_plot_data(val_max_pnt, val_ts, i)
    CTSR.VI <- output_list[[1]]
    CTSR.RF <- output_list[[2]]
    ACP.table <- output_list[[3]]

    max.df <- AnMaxVI(CTSR.VI)
    # Pull the key components from the result
    anu.VI <- max.df$Max #the VI values
    VI.index <- max.df$index #the indes values
    Max.Month <- max.df$Max.Month #month if the year the even occured

    CTS.Str <- ACP.calculator(
      CTSR.VI, ACP.table, ACT.table, allow.negative = allow.negative,
      allowneg.retest = allowneg.retest)

    CTSR.RF <- CTS.Str$CTSR.precip #RF values
    CTSR.TMraw <- CTS.Str$CTSR.rawtemp
    # Check for the presence of temperature data
    if (is.null(CTSR.TM)) {
      CTSR.TM <- CTS.Str$CTSR.tmp #Temperature values, null if temp is not considered
    }
    details.CTS.VPR <- CTS.Str$summary #Summay of the FIT between the CTS.VRP
    CTSR.osp <- CTS.Str$CTSR.osp #CTS Off set period
    CTSR.acp <- CTS.Str$CTSR.acp #CTS Sccumulation period
    CTSR.tosp <- CTS.Str$CTSR.tosp #CTS Off set period
    CTSR.tacp <- CTS.Str$CTSR.tacp #CTS Sccumulation period


    if (class(CTSR.RF) != "ts") {
      stop("CTSR.RF Not a time series object")
    }
    # get the time data out
    start.ti <- time(CTSR.VI)
    freq <- frequency(CTSR.VI)
    # check the two ts object cover the same time period
    start.ti2 <- time(CTSR.RF)
    freq2 <- frequency(CTSR.RF)
    #Check the start dates and the frequency are correct
    if (!identical(start.ti, start.ti2)) {
      stop("ts objects do not have the same time, (CTSR.VI & CTSR.RF)")}
    if (!identical(freq, freq2)) {
      stop("ts objects do not have the same frequency, (CTSR.VI & CTSR.RF)")}

    precip.df <- AnnualClim.Cal(anu.VI, VI.index, ACP.table, ACT.table = ACT.table, allow.negative = allow.negative)
    osp <- precip.df$osp # offset period
    acp <- precip.df$acp # Accumulation period
    tosp <- precip.df$tosp # offset period
    tacp <- precip.df$tacp # Accumulation period
    acu.RF <- precip.df$annual.precip # precip values
    acu.TM <- precip.df$annual.temp # precip values
    details.VPR <- precip.df$summary

    st.ti <- time(anu.VI)
    st.f <- frequency(anu.VI)
    st.ti2 <- time(acu.RF)
    st.f2 <- frequency(acu.RF)

    output_list_1 <- bfas_restrend(CTSR.VI, CTSR.RF, CTSR.TM, season, BFAST.raw, h, CTSR.osp, CTSR.acp, CTSR.tosp, CTSR.tacp, osp, acp, tosp, tacp)

    result <- output_list_1[[1]]
    details.CTS.VPR <- output_list_1[[2]]

    tss_restrend_row_coef <- make_result_df(result, details.CTS.VPR)
    tss_restrend_df <- rbind(tss_restrend_df, tss_restrend_row_coef)
}
write_csv(tss_restrend_df, 'output/plot_data/all_countries/tss_restrend_results.csv')
tss_restrend_df <- read_csv('output/plot_data/all_countries/tss_restrend_results.csv')
tss_restrend_df <- tss_restrend_df[tss_restrend_df$fit =='RESTREND.fit',]
```

Analyse TSS RESTREND analysis
```{r}
plot_ly(tss_restrend_df[tss_restrend_df$fit =='RESTREND.fit',], x = ~Ecosystem, y = ~slope, color = ~regreened, text= ~plotID, type = "box") %>% layout(boxmode = "group")

plot_ly(val_mae, y = ~mae_0, color = ~regreened, text= ~plotID, type = "box") %>% layout(boxmode = "group")
```



function to run bfast and restrend
```{r}
prepare_plot_data <- function(val_max_pnt, val_ts, i){
  plot_df <- val_max_pnt[val_max_pnt$plotID==i,]
  plot_ts <- ts(plot_df[,c("ndvi_max", "prcp_sum")], start = min(plot_df$Year), end = max(plot_df$Year), frequency = 1)

  prcp_df <- val_ts  %>% 
    filter(yearmon >= as.Date('2013-01-01') & yearmon < as.Date('2023-01-01'),
          plotID == i)
  ndvi_df <- val_ts_pnt %>% 
    filter(yearmon >= as.Date('2013-01-01') & yearmon < as.Date('2023-01-01'),
          plotID == i)
    
  ndvi_ts <- ts(ndvi_df[,c("ndvi_int")], start = c(2014, 1), end = c(2022, 12), frequency = 12)
  prcp_ts <- ts(prcp_df[,c("prcp_month")], start = c(2013, 1), end = c(2022, 12), frequency = 12)

  ACP.table <- climate.accumulator(CTSR.VI = ndvi_ts, clim.data = prcp_ts, 
  max.acp = 4, max.osp = 2)

  CTSR.VI <- ndvi_ts
  CTSR.RF <- window(prcp_ts, start = 2014)

  return_list <- list(CTSR.VI, CTSR.RF, ACP.table)

  return(return_list)
}


check_chow_breakpoints <- function(bp, anu.VI, acu.RF, VI.index, acu.TM, sig){
    bp <- as.numeric(bkp$bkps)

    if(length(bp) > 1){
      bp <- bp[2]
    }
    if(bp > 30 & bp < 75){
      res.chow <- CHOW(anu.VI, acu.RF, VI.index, bp, acu.TM = acu.TM, sig = sig)
      # Pull out the key values from the CHOW
      brkp <- as.integer(res.chow$bp.summary["yr.index"]) #this isn't right
      chow.sum <- res.chow$bp.summary
      chow.bpi <- res.chow$allbp.index
      # Use the CHOW results to set the testmethod
      test.Method = res.chow$n.Method
    } else{
      bp <- if_else(bp < 30, 30, 75)
      res.chow <- CHOW(anu.VI, acu.RF, VI.index, bp, acu.TM = acu.TM, sig = sig)
      # Pull out the key values from the CHOW
      brkp <- as.integer(res.chow$bp.summary["yr.index"]) #this isn't right
      chow.sum <- res.chow$bp.summary
      chow.bpi <- res.chow$allbp.index
      # Use the CHOW results to set the testmethod
      test.Method = res.chow$n.Method
    }
    return(list(bp, brkp, chow.sum, chow.bpi, test.Method))
}


bfas_restrend <- function(CTSR.VI, CTSR.RF, CTSR.TM, season, BFAST.raw, h, CTSR.osp, CTSR.acp, CTSR.tosp, CTSR.tacp, osp, acp, tosp, tacp){

  bkp <- VPR.BFAST(CTSR.VI, CTSR.RF, CTSR.TM=CTSR.TM, season = season, BFAST.raw = BFraw, h = h)
  # Extract the key values from the BFAST result
  bp <- bkp$bkps
  BFAST.obj <- bkp$BFAST.obj #For the models Bin
  CTS.lm <- bkp$CTS.lm #For the Models Bin
  bp <- bp[!bp %in% exclude] #remove breakpoints in the exclude list (Sensor transitions)
  BFT <-  bkp$BFAST.type #Type of BFAST used


  acum.df <- data.frame(
    CTSR.osp = CTSR.osp, CTSR.acp = CTSR.acp, CTSR.tosp = CTSR.tosp, CTSR.tacp = CTSR.tacp,
    osp = osp, acp = acp, tosp = tosp, tacp = tacp,  osp.b4 = NaN, acp.b4 = NaN, tosp.b4 = NaN,
    tacp.b4 = NaN, osp.af = NaN, acp.af = NaN, tosp.af = NaN, tacp.af = NaN
    )

  if (class(bp) == "logical" | length(bp) == 0) {#Should catch both the false and the no breakpoints
    # no breakpoints detected by the BFAST
    bp <- FALSE
    test.Method = "RESTREND" # MEthod set to determine further testing
    # Chow summary populated with false
    chow.sum <- data.frame(abs.index = FALSE, yr.index = FALSE, reg.sig = FALSE, VPR.bpsig = FALSE)
      chow.bpi <- FALSE

  }else{# Breakpoints detected by the BFAST
    chow_breakpoints <- check_chow_breakpoints(bp, anu.VI, acu.RF, VI.index, acu.TM, sig)
    bp <- chow_breakpoints[[1]]
    brkp <- chow_breakpoints[[2]]
    chow.sum <- chow_breakpoints[[3]]
    chow.bpi <- chow_breakpoints[[4]]
    test.Method = chow_breakpoints[[5]]
  }

  if (test.Method == "RESTREND") {

    result <- RESTREND(anu.VI, acu.RF, VI.index, acu.TM=acu.TM, sig = sig, retnonsig=retnonsig)

  }else if (test.Method == "seg.RESTREND") {

    breakpoint = as.integer(res.chow$bp.summary[2])
    result <- seg.RESTREND(anu.VI, acu.RF, VI.index, brkp, acu.TM=acu.TM, sig=sig, retnonsig=retnonsig)

  }else if (test.Method == "seg.VPR") {

    if ((!rf.b4) || (!rf.af)) {

      VPRbp.df <- AnnualClim.Cal(anu.VI, VI.index, ACP.table, ACT.table=ACT.table, Breakpoint = brkp, allow.negative = allow.negative)
      rf.b4 <- VPRbp.df$rf.b4
      rf.af <- VPRbp.df$rf.af
      tm.b4 <- VPRbp.df$tm.b4
      tm.af <- VPRbp.df$tm.af
      # Check if temp is insignificant either side of the breakpoint in the VPR,
      # if yes, remove temp from segmented VPR
      if (is.null(tm.b4) && is.null(tm.af)) {acu.TM = NULL}
      #Add the segmented offset periods and accumulation periods to the existing dataframe
      acum.df$osp.b4 <- VPRbp.df$osp.b4
      acum.df$acp.b4 <- VPRbp.df$acp.b4
      acum.df$tosp.b4 <- VPRbp.df$tosp.b4
      acum.df$tacp.b4 <- VPRbp.df$tacp.b4
      acum.df$osp.af <- VPRbp.df$osp.af
      acum.df$acp.af <- VPRbp.df$acp.af
      acum.df$tosp.af <- VPRbp.df$tosp.af
      acum.df$tacp.af <- VPRbp.df$tacp.af
    }

    breakpoint = as.integer(res.chow$bp.summary[2])

    result <- seg.VPR(anu.VI, acu.RF, VI.index, brkp, rf.b4, rf.af, acu.TM, tm.b4, tm.af, sig=sig, retnonsig=retnonsig)
  }

  if (abs(result$summary$Total.Change > (max(CTSR.VI)-min(CTSR.VI)))){
    print("Non Valid estimate produced, returning zero")
    result$summary$Total.Change = 0
    result$summary$Method = "InvalidValueError"
  }


  result$TSSRmodels$CTS.fit <- CTS.lm
  result$TSSRmodels$BFAST <- BFAST.obj
  # Complete Time series values
  result$ts.data$CTSR.VI <- CTSR.VI
  result$ts.data$CTSR.RF <- CTSR.RF
  if (!is.null(ACT.table)) {# Add Temperature if present
    result$ts.data$CTSR.TMraw <- ts(ACT.table[1, ], start = c(start(CTSR.VI)[1], start(CTSR.VI)[2]), frequency = 12)
    result$ts.data$CTSR.TM <- CTSR.TM
    }else{
      result$ts.data$CTSR.TM <- CTSR.TM
      result$ts.data$CTSR.TMraw <- CTSR.TM
    }

  output_list <- list(result, details.CTS.VPR)

  return(output_list)
}


make_result_df <- function(result, details.CTS.VPR){
  # add to the ols summary table
  result$ols.summary$OLS.table["CTS.fit",] <- details.CTS.VPR

  ############ Put result into dataframe
  tss_restrend_row_coef <- data.frame(result$ols.summary$OLS.table)
  tss_restrend_row_coef$fit <- row.names(tss_restrend_row_coef)
  tss_restrend_row_coef$plotID <- i
  tss_restrend_row_coef$country <- val_max_pnt$country[val_max_pnt$plotID==i][1]
  tss_restrend_row_coef$regreened <- val_max_pnt$regreened[val_max_pnt$plotID==i][1]
  tss_restrend_row_coef$Ecosystem <- val_max_pnt$Ecosystem[val_max_pnt$plotID==i][1]

  return(tss_restrend_row_coef)
}

```







# Alternative validation using visual inspection of plots (new script)
```{r}
sf::sf_use_s2(FALSE)

plots <- st_read('output/plot_data/all_countries/Countries_plots_green.GeoJSON')

plots <- plots %>% 
  group_by(county) %>% 
  mutate(county_ndvi = mean(ndvi_mean, na.rm=TRUE),
        Ecosystem = if_else(county_ndvi < 0.3, 'Arid', 'Semi-arid'),
        Ecosystem = if_else(county_ndvi > 0.45, 'Sub-humid', Ecosystem)) 
plots$area <- as.numeric(st_area(plots))

set.seed(100)
random_sites <- plots %>%
  mutate(high_none = if_else(mae > 1, 'high', 'low')) %>%
  filter(area > 0.1) %>% 
  group_by(Ecosystem, high_none) %>% 
  sample_n(size=50) %>% 
  ungroup() %>% 
  select(plotID) %>% 
  arrange(desc(plotID))

st_write(random_sites, 'output/plot_data/all_countries/random_val_sites.GeoJSON')
st_write(random_sites, 'output/plot_data/all_countries/random_val_sites.csv', driver = 'CSV')
random_sites %>% 
  st_combine() %>% 
  st_write('output/plot_data/all_countries/random_val_sites_multi.GeoJson')
```

Visualise time series of validation sites
```{r}
random_sites <- st_read('output/plot_data/all_countries/random_val_sites.GeoJSON')  %>% arrange(desc(plotID)) 
random_sites$area = as.numeric(st_area(random_sites))

l8_ts <- read_csv('output/time_series/Countries_l8_ts.csv')

l8_fc_plt_dt <- read_csv('output/time_series/Countries_ts_fc_plt2.csv')
l8_fc_plt_dt <- l8_fc_plt_dt %>% 
  mutate(yearmonth = yearmonth(yearmon))

load('output/models/Countries_l8_fc_plt2.RDS')

plt_stat_fit <- read_csv('output/plot_data/all_countries/plt_stat_fit.csv')


plt <- random_sites$plotID[101]
l8_fc_plt %>% 
  filter(plotID==plt) %>% 
  mutate(ci_95 = hilo(ndvi_int,95),
         upper_95=ci_95$upper,
         lower_95=ci_95$lower,
         ci_80 = hilo(ndvi_int, 80),
         upper_80=ci_80$upper,
         lower_80=ci_80$lower,
         ci_50 = hilo(ndvi_int, 50),
         upper_50=ci_50$upper,
         lower_50=ci_50$lower) %>% 
  ggplot()+
  geom_point(data = l8_ts[l8_ts$plotID==plt,], aes(x = date, y = ndvi), alpha=0.2,size=2)+
  geom_line(data = l8_fc_plt_dt[l8_fc_plt_dt$plotID==plt,], aes(x = as.Date(yearmonth), y = prcp / 1500),lwd=1,col='darkblue', lty = 2)+
  geom_line(data = l8_fc_plt_dt[l8_fc_plt_dt$plotID==plt,], aes(x = as.Date(yearmonth), y = ndvi_int),lwd=1,col='black')+ 
  
  #geom_ribbon(aes(x=as.Date(yearmonth), ymin=lower_80, ymax=upper_80), alpha=0.2, fill='orange')+
  #geom_line(data = l8_fc_plt_dt[l8_fc_plt_dt$plotID==plt,], aes(x=as.Date(yearmonth), y=ndvi_pred),col='brown',lwd=0.9,lty=2)+
  
  #annotate('text', x=as.Date('2021-02-01'),y=0.9, 
  #         label=paste('MAEp =',round(plt_stat_fit[plt_stat_fit$plotID==plt,]$mae,2)), size=3.5)+
  annotate('text', x=as.Date('2016-02-01'),y=0.9, 
           label=plt, size=3.5)+
  labs(y='NDVI')+
  theme(axis.title.x = element_blank(),
        panel.spacing = unit(0, "lines"),
        panel.background = element_rect(fill='white', colour='grey'),
        panel.grid.major = element_line(color='grey',linewidth = 0.1),
        axis.text = element_text(size=12),
        axis.title = element_text(size=14))+
  ylim(0,1)


```
